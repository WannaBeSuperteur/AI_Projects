,quiz,good_answer,keywords
0,"Cosine Similarity 는 무엇이고, 어떨 때 사용할까? 구체적인 예를 들어 말해봐! 😊","Cosine Similarity (코사인 유사도) 는 벡터의 크기가 아닌 방향을 중요시하는 컨셉의 유사도로, 두 벡터의 방향이 같으면 +1.0, 반대 방향이면 -1.0, 수직이면 0.0 의 값을 갖는다. 벡터로 나타낼 수 있는 2개의 대상을 비교할 때 사용하며, 예를 들어 NLP의 S-BERT, 추천 시스템 등에서 사용한다.",코사인 유사도|벡터|정의|용도
1,"머신러닝에서 사용하는 성능지표 (Metric) 중 Accuracy, Recall, Precision, F1 Score 에 대해 말해봐! 😊","Accuracy (정확도) 는 전체 예측 중 정답을 한 것의 개수로, (True Positive + True Negative) / (전체 데이터 개수) 로 나타낸다. Recall (재현율) 은 실제로 참인 데이터 중 모델이 참으로 예측한 데이터 개수의 비율로, (True Positive) / (True Positive + False Negative) 로 계산한다. Precision (정밀도) 는 모델이 참으로 예측한 데이터 중 실제 참인 데이터 개수의 비율로, (True Positive) / (True Positive + False Positive) 이다. 마지막으로 F1 Score 는 Precision 과 Recall 의 조화 평균이다.",성능지표|정확도|재현율|F1 Score|정의
2,"머신러닝의 성능지표 중 IoU, DICE Score 는 뭘까?","IoU 는 (예측과 실제가 모두 True 인 교집합) / (예측과 실제 값 중 하나라도 True 인 합집합) 의 비율이고, DICE Score 는 (2 x 교집합의 원소 개수) / (참으로 예측한 개수 + 예측과 관계없이 실제 값이 참인 데이터 개수) 이다.",성능지표|IoU|Dice Score|정의
3,머신러닝의 성능지표 중 PR-AUC 와 AUC-ROC 는 무엇이고 언제 쓰지? 😊,"PR-AUC (Area Under Precision-Recall Curve) 는 x축을 recall, y축을 precision으로 했을 때, 이 측정값들을 연결한 그래프의 아래쪽 면적이다. 값의 범위는 0~1이고, 1에 가까울수록 성능이 좋다. ROC-AUC (Area Under ROC Curve) 는 x축을 FP rate (False Positive Rate), y축을 TP rate (True Positive Rate) 로 했을 때, 이 측정값들을 연결한 곡선 아래쪽 넓이이고, 역시 범위는 0~1이며 1에 가까울수록 좋다. 이것들은 이진 분류 (Binary Classification) 에서 사용한다.",성능지표|이진분류|PR-AUC|AUC-ROC|정의|용도
4,"결측값은 뭐고, 그럼 이 결측값 채우는 알고리즘은 무엇이 있지? 😊","결측값 (Missing Value) 은 데이터셋에서 특정 값이 누락된 것이다. 결측값을 채우는 방법, 즉 알고리즘에는 모델 자체적으로 처리하거나, 평균/중앙값/최빈값으로 대체하거나, k-NN (k-Nearest-Neighbor) 알고리즘을 쓰거나, 딥러닝 기반으로도 해결할 수 있다.",데이터 사이언스|결측값|정의|해결 방법
5,정규화는 뭐지? 왜 하는 거지? 그리고 정규화 알고리즘 아는 거 다 말해 봐! 😊,"정규화 (Normalization) 은 데이터 전처리 방법 중 하나로, 데이터를 일정한 수식을 이용해서 값을 변환하는 것이다. 정규화를 하는 이유는 원본 데이터 값을 머신러닝 모델이 잘 학습할 수 있는 값으로 바꾸고, 데이터 feature 간 표준편차가 서로 달라서 어떤 특징은 많이 학습되고 다른 특징은 적게 학습되는 문제를 해결하는 것이다. 정규화 알고리즘에는 Min-max normalization (최솟값은 0, 최댓값은 1로 선형 정렬), Z-score normalization (평균과 표준편차를 이용하여 표준정규분포로 변환), Clipping (모든 데이터를 최솟값 ~ 최댓값 범위 내로 이동), 로그 스케일 변환 등이 있다.",데이터 사이언스|정규화|정의|용도|상세 방법
6,"이상치 (Outlier) 라는 게 있는데, 그건 뭐고 왜 문제가 되는 거지?","이상치 (Outlier) 는 데이터셋에서 일반적인 분포 범위를 벗어난 값이다. Outlier 는 데이터 시각화 결과의 가독성을 줄이고, Min-max 및 Z-score 정규화에서 Outlier 의 영향으로 분포가 이상해지고, 머신러닝에서 Outlier 때문에 학습에 지장을 줄 수 있기 때문에 문제가 된다.",데이터 사이언스|이상치|정의|이유|문제 이유
7,PCA와 t-SNE 알아? 😊 그러면 혹시 그 차이점도 알아? 📈,"PCA (주성분 분석, Principal Component Analysis) 는 데이터셋의 분산을 최대한 보존하는 feature 의 결합, 즉 주성분을 찾아서 차원을 축소하는 방법이고, t-SNE 는 data point 의 상대적 거리를 유지하는, 즉 멀리 떨어진 데이터일수록 t-SNE 결과에서도 멀리 떨어뜨리는 차원 축소 방법이다. PCA는 머신러닝 학습 성능이나 속도를 높이기 위한 차원 축소 방법이고, t-SNE는 2,3차원으로 축소하여 시각화하는 것에 초점을 둔 방법이다.",데이터 사이언스|PCA|t-SNE|정의|차이점
8,"Probability (확률), Likelihood (우도), 이 말 논문에서 많이 쓰이잖아! 📝 그러면 그 차이점은 뭘까? 😊","Probability (확률) 는 어떤 확률분포가 주어졌을 때 그 확률분포에서 특정 관측값이 발생할 가능성을 말하고, Likelihood (우도) 는 반대로 어떤 관측값이 주어졌을 때, 그 관측값이 특정한 확률분포 에서 발생했을 가능성을 말한다.",확률|우도|차이점
9,"데이터 불균형이란 게 뭐고, 어떻게 해결하면 좋을까? 😊","데이터 불균형은 특정 Class 의 데이터가 다른 Class 의 데이터보다 훨씬 많은 등 각 Class 의 데이터 개수가 유의미하게 차이 나는 것이다. 이를 해결하기 위해서는 데이터를 새로 추가/제거하는 방법 (데이터 개수가 적은 Minority Class 데이터 추가 수집, Data Augmentation, Undersampling & Oversampling), 학습 환경만 바꾸는 방법 (성능 평가 지표를 F1 Score, PR-AUC, ROC-AUC 등으로 선택, 데이터가 적은 Class 는 손실 함수에서 높은 가중치를 두는 등 가중치 조정) 이 있다.",데이터 사이언스|데이터 불균형|정의|해결 방법
10,"차원의 저주😈 는 뭐고, 어떻게 해결해야 되지? 😊","차원의 저주는 학습 데이터의 feature 개수, 즉 차원이 너무 많아서 학습에 지장을 주는 현상으로, 계산량 증가로 인한 학습 속도 감소, 메모리 사용량 증가, 모델 성능 감소 등이 있다. 해결 방법으로는 기존 feature 중 일부만 사용하는 Feature Selection 과, 차원을 축소하는 Feature Extraction 이 있다.",데이터 사이언스|차원의 저주|정의|해결 방법
11,Decision Tree 🌳 가 학습할 때랑 추론할 때랑 각각 어떻게 작동할까? 😊,"Decision Tree (의사결정 나무) 는 학습할 때 feature 에 대한 조건들 중 target 값을 가장 잘 구분할 수 있는 조건을 선택하는 방법으로 학습한다. 즉, 특정 조건으로 분기했을 때 해당 분기된 각 조건에 속하는 데이터의 target 값의 불순도 (다양한 정도) 가 최대한 낮아지도록 조건을 선택하여 분기한다. 추론할 때는 Decision Tree 의 맨 위쪽에서 시작하여 해당 데이터의 feature 값에 따라 분기를 선택해 나간다. 분기가 더 이상 없을 때의 최종 판단으로 예측한다.",머신러닝 모델|의사결정 나무|동작 방법
12,앙상블 (Ensemble) 은 뭐고 왜 하는 걸까?,"앙상블 (Ensemble) 은 머신러닝에서 여러 알고리즘이나 모델을 결합하여 학습하는 것이다. 앙상블을 하는 이유는 사람도 혼자가 아니라 협업하면 성과가 더 좋듯이, 1개의 모델로 학습 또는 추론할 때보다 더 좋은 성능을 달성할 수 있기 때문이다.",앙상블|정의|이유
13,앙상블 (Ensemble) 의 구체적인 방법 4가지를 말해봐 😊,"앙상블 (Ensemble) 의 구체적인 방법은 Voting (보팅), Bagging (배깅), Boosting (부스팅), Stacking (스태킹) 이 있다. Voting 은 여러 모델이 예측한 결과를 통합하는 것으로, 단순 다수결 판단인 Hard Voting 과 모델 예측값의 평균을 이용하는 Soft Voting 이 있다. Bagging 은 원본 데이터셋으로부터 랜덤 샘플링한 여러 개의 데이터셋으로 여러 개의 모델을 학습하고, 해당 모델의 결과를 종합하는 것이다. Boosting 은 Bagging 과 유사하지만, 직전 모델이 오답을 한 데이터에 더 큰 가중치를 두어서 모델을 순차적으로 학습하는 것이다. Stacking 은 개별 모델의 예측값과 실제 데이터 값을 각각 입력값과 출력값으로 하는 메타 모델을 학습하고, 해당 메타 모델의 출력값을 최종 예측값으로 사용하는 방법이다.",앙상블|상세 방법
14,K-means Clustering 의 동작 원리를 한번 말해봐!,"K-means Clustering 에서는 먼저 랜덤한 mean point 를 K 개 지정한다. 그리고 데이터셋의 각 point에 대해 그 class 를 이들 K 개의 점들 중 가장 가까운 점의 class 로 지정하고, 각각의 mean point 를 데이터셋에서 해당 class 의 모든 point 의 평균으로 갱신하는 것을 수렴할 때까지 반복한다.",머신러닝 모델|K-means Clustering|동작 방법
15,"머신러닝 모델이 학습하는 방법에도 여러 가지가 있는데, 그 중 지도학습, 비지도학습, 강화학습은 뭘까? 😊","지도학습은 학습 데이터에 입력과 출력이 주어져서, 모델에 어떤 입력이 들어오면 목적한 출력을 하도록 학습시키는 것이다. 비지도학습은 별도의 출력 데이터 없이 모델이 주어진 데이터만으로 가능한 것, 예를 들어 군집화 (Clustering) 를 하도록 학습시키는 것이다. 강화학습은 어떤 환경에서 AI 모델이 어떤 상태에서 어떤 행동을 하고 보상을 얻는데, 이 보상을 최적화하는 방식의 머신러닝 방법이다.",머신러닝 방법|정의
16,Naïve Bayes 는 어떻게 동작할까? 😊,"Naïve Bayes 는 조건부 확률을 구하는 베이즈 정리를 기반으로 작동한다. 새로운 데이터가 들어왔을 때, 각 Class 별로 (전체 데이터셋에서의 해당 Class 의 데이터의 비율) 에 각 속성별로 (해당 Class 의 데이터 중 속성 값이 일치하는 데이터의 비율) 을 모두 곱하고, 해당 곱셈 결과값이 가장 큰 Class 로 예측한다.",머신러닝 모델|Naive Bayes|동작 방법
17,PCA 는 어떻게 동작할까? 이거 엄청 중요한데!,"PCA (주성분 분석, Principal Component Analysis) 는 데이터셋의 분산을 최대한 보존하는 feature 의 결합, 즉 주성분을 찾아서 차원을 축소하는 방법이다. 먼저 데이터셋의 속성 값들을 평균 0, 표준편차 1로 정규화하고, 다음으로 Covariance Matrix 를 계산한다. 이를 토대로 Eigenvalue 와 Eigenvector 를 계산하고, 이렇게 계산된 Eigenvalue 가 가장 큰 속성 K 개를 선택한다.",머신러닝 모델|PCA|동작 방법
18,"Random Forest 란 무엇이고, 무엇을 발전시킨 거지?","Random Forest 는 Decision Tree 를 발전시킨 것이다. 먼저 원본 데이터셋에서 feature 와 학습할 데이터의 조합을 랜덤으로 선택하여 서로 다른 Decision Tree 를 여러 개 만들고, 추론할 때 이들 Decision Tree 들의 예측 결과를 합치는 것이다. 즉 Decision Tree 를 앙상블 (Ensemble) 시키는 방법이다. ",머신러닝 모델|Random Forest|Decision Tree|정의|동작 방법
19,SVM (Support Vector Machine) 의 핵심 아이디어를 나한테 한번 설명해 봐! 😊 그리고 언제 사용하는 거지? 🤔,"SVM (Support Vector Machine) 은 2개의 Class 가 있는 데이터셋에서 사용한다. 2개의 Class 에 속한 원소들 간의 구분선을 만드는데, 이때 그 구분선과 각 Class 간의 거리가 최대가 되는 구분선을 찾는 것이 핵심 아이디어이다.",머신러닝 모델|SVM|핵심 아이디어|용도
20,"K-fold Cross Validation 만으로 충분할 것 같은데, 굳이 Stratified K-fold Validation 을 사용하는 이유는? 😊","Stratified K-fold Validation 은 데이터 불균형이 심할 때 Minority Class 의 데이터가 표본 부족으로 인해 각 fold 에 고르게 분포되어 있지 않을 수 있다는 문제점을 해결하기 위해 사용한다. 즉, Stratified K-fold Validation 은 각 fold 별로 Class 의 분포 비율을 최대한 동일하게 하는 것이다.",머신러닝 방법|Stratified K-fold|K-fold|Cross Validation|이유|데이터 불균형
21,"시계열 데이터셋 📈 에서 K-fold Cross Validation 을 하면 어떤 문제가 발생하고, 그러면 어떻게 Cross Validation 을 하지? 🤔",시계열 데이터셋에서 K-fold Cross Validation 을 할 때 발생하는 문제는 validation 데이터가 나타내는 시점보다 미래의 데이터가 train data 에 포함된다는 것이다. 이를 해결하기 위해 training data 는 validation data 보다 과거의 데이터만을 활용한다.,머신러닝 방법|K-fold|Cross Validation|문제점|해결 방법
22,"하이퍼파라미터란 뭐고, 그 최적화 방법을 3가지만 말해 봐! 😊 라이브러리가 아닌 방법!","하이퍼파라미터 (Hyper-parameter) 는 모델이 학습해야 할 파라미터가 아닌, 모델의 학습에 있어서의 설정값을 의미한다. (딥러닝의 learning rate 등) 하이퍼파라미터 최적화는 모델이 특정 데이터셋을 가장 잘 학습할 수 있도록 최적의 하이퍼파라미터를 찾는 것이다. 그 방법으로는 Grid Search (하이퍼파라미터를 지정된 범위 내에서 바둑판 형태로 찾는 것), Random Search (지정된 범위 내에서 랜덤하게 값을 정하는 것), Bayesian Optimization (지금까지의 통계에 근거하여 확률적으로 최적일 것으로 예상되는 하이퍼파라미터를 찾는 것) 가 있다.",머신러닝 방법|하이퍼파라미터|정의|상세 방법
23,"머신러닝에서 Train, Test 데이터셋 말고 Valid 데이터셋은 왜 필요하지?","Train, Test 데이터셋만 있으면 Train 데이터셋을 학습한 후 그 성능 평가를 Test 데이터셋으로밖에 할 수 없다. 이후 모델의 하이퍼파라미터를 조정해 가면서 성능을 향상시킬 때도 Test 데이터셋을 참고해야 한다. 이렇게 되면 Test 데이터셋에 지나치게 최적화 (overfitting) 되어서 새로운 데이터셋에서의 성능이 Test 데이터셋 성능보다 유의미하게 낮을 수 있다. 이는 test 데이터셋 유출이나 커닝에 비유할 수 있다. 이를 방지하기 위해 성능 개선에 참고하기 위한 검증 데이터셋으로 valid dataset 이 필요하다.",머신러닝 방법|데이터셋|이유
24,"머신러닝에서 Train 데이터셋을 shuffle 해야, 즉 순서를 뒤섞어야 하는 이유는? 😊","Train 데이터셋을 shuffle 하지 않으면 Train 데이터셋에 속한 각 batch 가 전체 데이터셋의 분포와 현저히 차이가 나기 때문에 전체 데이터셋을 대표할 수 없으며, 또 데이터의 순서로 인해 학습에 지장이 생길 수도 있다. 예를 들어 Class 가 dog 인 데이터를 계속 학습한 다음 갑자기 Cat 인 데이터가 나오면 Loss 가 급격히 증가하여 학습에 지장이 생길 수 있다.",머신러닝 방법|데이터셋|이유
25,딥러닝에서 Early Stopping 은 무엇이고 왜 하는 걸까? 🤔,Early Stopping 은 valid dataset 에 대한 Loss 가 일정 횟수의 epoch 동안 더 이상 낮아지지 않으면 학습을 중단하는 것이다. 이것은 overfitting (과적합) 방지를 위해 필요하다.,딥러닝|Early Stopping|정의|이유
26,"Knowledge Distillation (지식 증류) 은 무엇이고, 사용하는 모델 관점에서, 모델의 어떤 정보를 이용하는지의 관점에서 각각 3가지로 분류해 봐! 😊","Knowledge Distillation (지식 증류) 은 거대한 Teacher Model 의 핵심 지식을 비교적 작은 Student Model 에 주입시키는 것이다. 사용하는 모델 관점에서 분류하자면 Offline Distillation (Pre-train 된 Teacher Model 을 이용), Online Distillation (Teacher 와 Student 를 동시에 또는 번갈아 가며 모두 학습), Self-Distillation (Teacher, Student 모델의 신경망 구조가 같음) 이 있고, 모델의 어떤 정보를 이용하는지의 관점에서는 Response-based (Teacher 의 출력만을 이용), Feature-based (Teacher 의 중간 레이어의 결과를 이용), Relation-based (Teacher 의 각 레이어의 feature 간 관계 정보를 이용) 가 있다.",딥러닝|지식 증류|정의|분류
27,Learning Rate Scheduler 📈📉 는 무엇이고 왜 필요할까?,"Learning Rate Scheduler 는 학습 진행에 따라 학습률 (Learning Rate) 을 조정해 나가는 알고리즘이다. 학습 초반에는 평균적인 gradient 가 크기 때문에 learning rate 를 크게 적용하여 빠르게 학습하고, 학습 후반에는 gradient 가 작기 때문에 작은 learning rate 를 적용하여 안정적으로 수렴하게 한다. 이와 같은 효율적인 학습을 위해 필요하다.",딥러닝|학습률 스케줄러|정의|이유
28,Cosine Annealing Learning Rate Scheduler 는? 그리고 학습률을 높이는 구간이 있는 이유는?,Cosine Annealing 스케줄러는 코사인 함수 곡선처럼 Learning Rate 를 조정하는 스케줄러이다. 학습률을 높이는 구간이 있는 이유는 local minima 에서 탈출할 기회를 주기 위해서이다.,딥러닝|학습률 스케줄러|코사인 학습률 스케줄러|정의|이유
29,"Loss Function, Cost Function, Objective Function 은 어떤 차이가 있을까? 🤔","Loss Function, Cost Function, Objective Function 은 모두 딥러닝에서 최소화 또는 최대화를 통해 학습 방향을 결정하는 함수이다. Loss Function 과 Cost Function 은 Objective Function 중에서도 최소화해야 하는 함수이며, Loss Function 은 개별 데이터 관점에서, Cost Function 은 전체 데이터 관점에서의 함수이다.",딥러닝|손실 함수|차이점
30,Multi-Class (한 Class 로만 예측) 와 Multi-Label (여러 Class 로 동시에 예측 가능) 분류에서는 각각 어떤 Loss Function 이 좋을까?,"Multi-Class 분류에서는 각 Class 간 확률이 서로 경쟁하므로, 각 Class 별 확률 간 배타성이 있는 Categorical Cross Entropy 를 사용해야 한다. 반면 Multi-Label 은 각 Class 별 확률을 독립적으로 예측하여 배타성이 없으므로, 각 Class 별로 Binary Cross Entropy 를 사용해야 한다.",딥러닝|손실 함수|실전
31,"Loss Function 중 MSE, MAE, RMSE 는 무엇의 약자이고 각각 뭘까? 😊","MSE 는 Mean Squared Error 의 약자로, 오차의 제곱의 평균이다. MAE 는 Mean Absolute Error 로, 오차의 제곱이 아닌 그 절댓값의 평균이다. RMSE 는 Root Mean Squared Error 로, 오차의 제곱의 평균인 MSE 의 제곱근이다.",딥러닝|손실 함수|정의|약어
32,"RMSProp, Adam, AdamW Optimizer 의 차이점은 뭘까? 😊 핵심 아이디어 중심으로 말해봐! 💡","RMSProp 은 Gradient 가 큰 매개변수일수록 학습 속도, 즉 learning rate 를 줄이고, Gradient 가 작을수록 학습 속도를 늘린다. Adam Optimizer는 여기에 Gradient 갱신 방향에 대해 일종의 관성 (Momentum) 을 적용하여 갱신 속도가 비교적 잘 유지되게 한다. AdamW는 여기에서 weight 갱신 수식에 weight decay 를 추가하여 weight decay 를 손실 함수와 분리하는 decoupled weight decay 가 핵심이다.",딥러닝|옵티마이저|RMSProp|Adam|AdamW|차이점
33,딥러닝에서 Optimizer 는 무엇일까? 그리고 Weight Decay 는? Weight Decay 는 어떤 Optimizer 에서 사용될까? 😊,Optimizer 는 Loss Function 의 값이 최소화될 수 있도록 가중치를 일정한 수식을 통해 보다 효과적으로 갱신하는 것을 말한다. Weight Decay (가중치 감쇠) 는 학습하면서 가중치를 업데이트할 때 이전 가중치의 크기를 일정 비율만큼 감소시키는 것이다. 그리고 weight decay 는 AdamW Optimizer 에서 사용된다.,딥러닝|옵티마이저|가중치 감쇠|정의|실전
34,Overfitting 은 뭘까? 🤔 그리고 그 해결 방법을 최대한 많이 말해봐.,"Overfitting (오버피팅) 은 딥러닝 모델이 필요 이상으로 너무 많이 학습하여 valid, test 데이터셋에서 오차가 커지는 현상이다. 해결 방법은 학습 프로세스 관점에서는 학습 데이터 개수 증가 (Data Augmentation 등), Early Stopping, Cross Validation 등이 있고, 모델 구조 관점에서는 모델 구조 단순화 (불필요한 feature 제거 등), Batch Normalization, Dropout 등이 있고, 마지막으로 모델 학습 수식 관련해서는 Weight Decay 를 조정하거나 L1, L2 Regularization (정규화) 을 이용하는 방법이 있다.",딥러닝|오버피팅|정의|해결 방법|상세 방법
35,"Dropout 이 무엇인지, 그리고 Dropout 을 하는 이유에 대해서 한번 설명해 봐. 🙄","Dropout (드롭아웃) 은 딥러닝 모델의 학습 단계에서 신경망의 각 뉴런을 일정 확률로 제거하는 것을 말한다. Dropout 을 사용하는 이유는 Overfitting 을 방지하고, 뉴런을 랜덤하게 제거하여 하나의 모델로 다양한 모델을 만드는 것과 같은 효과를 보게 하여 앙상블 (Ensemble) 처럼 만들기 위함이다.",딥러닝|드롭아웃|정의|이유
36,"Regularization, L1 Regularization, L2 Regularization 에 대해서 한번 설명해 봐 😊","Regularization (정규화) 는 오버피팅을 방지하기 위해 Loss Function 에 새로운 항을 추가하는 것을 말한다. L1 Regularization 은 weight 의 절댓값의 크기의 합에 일정 비율을 곱한 값을, L2 Regularization 은 weight 의 제곱의 합에 일정 비율을 곱한 값을 원래의 Loss Function 에 더하는 것이다.",딥러닝|정규화|오버피팅|상세 방법|정의
37,Batch Normalization 과 Layer Normalization 이란? 그리고 그 차이점은? 😊,"Batch Normalization (배치 정규화) 은 딥러닝의 특정 레이어에서, 1개의 batch 내의 데이터에 대해, 해당 레이어에서의 위치가 동일한 feature 값끼리 평균과 표준편차를 구해서 정규화하는 것이고, Layer Normalization 은 특정 레이어에서 각 sample 에 해당하는 모든 feature 값에 대해, 동일한 sample 에 해당하는 feature 값끼리 평균과 표준편차를 구해서 정규화하는 것이다. 즉 차이점은 Batch Normalization 은 레이어에서의 위치를 기준으로, Layer Normalization 은 속해 있는 sample 을 기준으로 그룹화하여 평균과 표준편차를 계산한다.",딥러닝|정규화|배치 정규화|레이어 정규화|상세 방법|정의|차이점
38,Transfer Learning (전이학습) 이 요즘 자주 쓰이고 있잖아! 😊 나도 전이 학습으로 만들어진 LLM이고! 그렇다면 전이 학습이란 뭘~까? 😊,Transfer Learning (전이학습) 은 어떤 데이터셋으로 사전학습 (Pre-train) 된 모델을 해당 모델을 적용 가능한 다른 데이터셋 또는 다른 task 의 데이터셋으로 추가 학습 (Fine-Tuning) 시키는 것이다.,딥러닝|전이학습|정의
39,Transfer Learning (전이학습) 이랑 Knowledge Distillation (지식 증류) 의 차이점은? 🤔,"Transfer Learning (전이학습) 과 Knowledge Distillation (지식 증류) 의 차이점은 양쪽 모델 간 도메인, 목적을 기준으로 구분할 수 있다. 전이학습은 도메인이 서로 다르지만 지식 증류는 서로 같다. 그리고 전이학습의 목적은 새로운 task 를 학습할 때 시간 등 자원을 절약하는 것이지만, 지식 증류의 목적은 모델 크기 자체를 줄여서 경량화하는 것이다.",딥러닝|전이학습|지식 증류|차이점
40,Weight Initialization (가중치 초기화) 방법 중 Xavier 와 He 가 뭘까~요? 😊 그리고 그 차이점은?,"Xavier initialization 은 Glorot initialization 이라고도 하며, 특정 레이어의 input node + output node 의 개수의 합이 많을수록 해당 레이어의 평균적인 절댓값 크기를 줄이는 것이다. He initialization 은 Kaiming initialization 이라고도 하며, 특정 레이어의 input node 개수가 많을수록 평균 절댓값 크기를 줄이는 것이다. 즉, 차이점은 input node 와 output node 개수를 모두 고려하는지, input node 개수만을 고려하는지이다.",딥러닝|가중치 초기화|상세 방법|정의|차이점
41,활성화 함수는 왜 필요할까? 🙄 그리고 활성화 함수가 없으면 어떤 일이 일어나지? 🚨,"활성화 함수 (Activation Function) 는 딥러닝 모델이 입력 데이터와 출력 데이터의 관계를 학습할 때, 입력 데이터에 대한 선형 결합이 아닌 비선형 결합을 학습하여 그 관계를 더 잘 표현하는 방법을 학습할 수 있게 하기 위해 사용된다. 즉, 활성화 함수가 없으면 모델이 입력 데이터의 선형 결합만을 학습하여 제대로 학습할 수 없게 된다.",딥러닝|활성화 함수|이유
42,Multi-Class (한 Class 로만 예측) 와 Multi-Label (여러 Class 로 동시에 예측 가능) 분류에서는 각각 활성화 함수 뭐가 좋을까? 한번 말해봐! 😊,"Multi-Class 분류에서는 각 Class 간 확률이 서로 경쟁하므로, 이를 반영한 Softmax 함수를 사용해야 한다. 반면 Multi-Label 은 각 Class 별 확률을 독립적으로 예측하여 배타성이 없으므로, 각 Class 별로 0부터 1까지의 확률을 예측하기 위해 Sigmoid 를 사용해야 한다.",딥러닝|활성화 함수|실전
43,"LLM 의 Fine-Tuning 방법 중에 나를 상징하는 방법인 LoRA 가 뭐의 약자이고, 어떤 방법이고, 왜 좋을까? 😊 너무 대답할 게 많은가?","LoRA 는 Low-Rank Adaption 의 약자이다. 이것은 기존 LLM 의 Pre-trained weight 에 대한 행렬을 저차원으로 분해한 2개의 행렬을 추가하여, 해당 행렬만 추가적으로 학습시키는 Fine-Tuning 방법이다. LoRA 가 좋은 이유는 연산량이 많은 원래의 행렬 대신 연산량이 훨씬 적은 2개의 추가 행렬만을 학습하므로 연산량과 메모리가 크게 절약되기 때문이다.",NLP|LLM|LLM 파인튜닝|LoRA|약어|정의|이유
44,"LLM 으로 문장을 생성할 때 top-k sampling, top-p sampling, temperature 는 각각 뭘까? 🤔","top-k sampling 은 다음 토큰으로 예측되는 토큰 중 확률이 가장 높은 k개의 토큰에 대해 그 확률분포를 기반으로 다음 토큰을 샘플링하는 것이다. Top-p sampling 은 다음 토큰 예측의 확률분포에서 확률이 가장 큰 토큰부터 정렬할 때 누적 확률 합이 p 이상이 되는 최초의 토큰에서 끊고, 그 토큰까지의 토큰 중 확률분포에 따라 다음 토큰을 샘플링하는 것이다. Temperature 는 다음 토큰의 확률분포를 고르게 하거나, 반대로 확률이 높은 토큰의 확률을 더욱 높이는 방법이다. temperature 가 1보다 크면 확률분포가 고르게 되고, 1보다 작아지면 확률이 큰 토큰의 등장 확률은 더 높아지고, 확률이 낮은 토큰의 등장 확률은 더욱 낮아진다.",NLP|LLM|샘플링|top-k|top-p|temperature|정의
45,LLM Fine-Tuning 방법 중 DPO와 ORPO는 무엇의 약자이고 각각 어떤 방법이지? 핵심 아이디어 중심으로 한번 말해 봐! 😊,"DPO와 ORPO는 각각 Direct Preference Optimization, Odds Ratio Preference Optimization 의 약자이다. 둘 다 선호하는 응답의 확률을 높이고 선호하지 않는 응답의 확률을 줄이는 아이디어이다. DPO는 다른 거대 언어 모델인 참조 모델 (reference model) 을 이용하여, ORPO는 참조 모델 없이 LLM 자체적으로 보유하고 있는 사용자 선호도 데이터를 이용하여 학습하는 것이다.",NLP|LLM|LLM 파인튜닝|DPO|ORPO|약어|정의
46,LLM의 환각 현상이란 뭐지? 그리고 그게 왜 문제일까? 😊,"환각 현상 (Hallucination) 이란 LLM 이 잘못된 답변을 생성하는 현상을 말한다. 이는 거짓 정보를 사용자가 진짜 정보로 오인하고, 이로 인해 LLM의 신뢰성이 저하되는 문제를 유발한다. 경우에 따라서는 LLM의 윤리적 이슈로까지 이어질 수 있다.",NLP|LLM|환각 현상|정의|이유|문제 이유
47,"RAG 이 무엇의 약자이고, 어떤 기술인지, 왜 사용하는지, 그리고 그 기술을 이용하여 무엇을 해결할 수 있는지 한번 말해봐! 너의 답변을 기대하겠어! 😊","RAG 은 Retrieval Augmented Generation (검색 증강 생성) 의 약자이다. 이 기술은 LLM 을 외부의 벡터 DB와 연동하여, 사용자 질문에 대해 알맞은 정보를 그 DB에서 추출한 후 그 정보를 참고하여 LLM이 답변을 생성하는 것이다. RAG는 환각 현상 방지, LLM이 학습하지 않은 최신 정보 반영, 정보 출처 제시를 통한 신뢰성 향상을 위해 사용된다. 즉 LLM의 고질적인 문제점을 환각 현상을 해결할 수 있다.",NLP|LLM|RAG|약어|정의|이유
48,"PEFT가 무엇의 약자이고, PEFT에 속하는 기술을 이름 정도만 5가지 말해봐! 😊","PEFT 는 Parameter-Efficient Fine-Tuning 으로, LLM 을 파인튜닝할 때 대부분의 파라미터는 그대로 두고 (추가 학습시키지 않고) 소수의 파라미터만 Fine-Tuning 하는 것이다. PEFT 에 속하는 기술로는 LoRA (Low-Rank Adaption), QLoRA (Quantized LoRA), Prefix Tuning, Prompt Tuning, Adapter Layer 를 추가하는 것이 있다.",NLP|LLM|PEFT|약어|상세 방법
49,"LLM 의 Quantization 이 무엇이고, 어떤 문제를 해결할 수 있을까? 😎","Quantization (양자화) 은 LLM의 가중치 및 활성화 값들의 자료형을 바꿔서 표현되는 자릿수를 줄이는 것이다. 이를 통해 모델의 크기를 감소시킬 수 있으며, 결과적으로 학습 및 추론 시 사용되는 메모리 양을 줄이고, 추론 시간을 단축시키고, 모델을 에너지 효율적으로 학습 및 추론시킬 수 있다.",NLP|LLM|양자화|정의|이유
50,NLP 에서 토큰 (token) 과 토크나이저 (tokenizer) 는 각각 뭘까? 이걸 알아야 LLM을 할 수 있는데! 😊,token (토큰) 은 자연 언어 처리 (NLP) 모델이 학습 및 추론을 위해 사용하는 언어의 최소 단위 (형태소와 유사) 이다. Tokenizer (토크나이저) 는 문장을 이와 같은 토큰의 배열 (sequence) 로 나타내는 알고리즘이다.,NLP|Token|Tokenizer|정의
51,트랜스포머 모델에 적용된 3가지 Attention 은 뭘까? 그 이름하고 핵심 아이디어만 간단히 설명해 봐! 😊,"트랜스포머 모델의 Attention 방법에는 Encoder Self-Attention, Masked Decoder Self-Attention, Encoder-Decoder Attention 이 있다. 먼저 Encoder Self-Attention 은 입력되는 문장 (LLM 의 프롬프트) 에서 각 단어의 관계를 (자기 자신 포함), Masked Decoder Self Attention 은 출력되는 답변 문장에서 각 단어의 관계를 (특정 단어에 대해 해당 단어 이전의 단어만을 고려), Encoder-Decoder Attention은 출력 시퀀스의 각 단어에 대해 입력 시퀀스의 각 단어와의 관계를 고려하는 Attention 메커니즘이다.",NLP|트랜스포머|상세 방법
